#!/usr/bin/env python
PACKAGE = "pacman_vision"
from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator()
#           Name    Type  ReconfigureLevel    Description   Default   Min   Max
#Node
gen.add("enable_estimator", bool_t, 0, "Enable Estimator module", False)
gen.add("enable_broadcaster", bool_t, 0, "Enable Broadcaster module", False)
gen.add("enable_tracker", bool_t, 0, "Enable Tracker module", False)
gen.add("passthrough", bool_t, 0, "Enable Passthrough filter, applied to every pointcloud acquired from asus sensor", True)
gen.add("downsampling", bool_t, 0, "Enable VoxelGrid filter, applied after the eventual passthrough filter and plane segmentation", False)
gen.add("plane_segmentation", bool_t, 0, "Enable RANSAC fitting for plane and removal of found plane, applied after the eventual passthrough filter", False)
gen.add("keep_organized", bool_t, 0, "Keep the point cloud organized during various filters, if possible (voxel grid breaks organized structure of point cloud).", False)
gen.add("pass_xmin", double_t, 0, "Passthrough filter lower bound for X (in meters), only relevalt if filtering is enabled, otherwise ignored.", -0.5, -5.0, 5.0)
gen.add("pass_xmax", double_t, 0, "Passthrough filter upper bound for X (in meters), only relevalt if filtering is enabled, otherwise ignored.", 0.5, -5.0, 5.0)
gen.add("pass_ymin", double_t, 0, "Passthrough filter lower bound for Y (in meters), only relevalt if filtering is enabled, otherwise ignored.", -0.5, -5.0, 5.0)
gen.add("pass_ymax", double_t, 0, "Passthrough filter upper bound for Y (in meters), only relevalt if filtering is enabled, otherwise ignored.", 0.5, -5.0, 5.0)
gen.add("pass_zmin", double_t, 0, "Passthrough filter lower bound for Z (in meters), only relevalt if filtering is enabled, otherwise ignored.", 0.2, 0.1, 10.0)
gen.add("pass_zmax", double_t, 0, "Passthrough filter upper bound for Z (in meters), only relevalt if filtering is enabled, otherwise ignored.", 1.0, 0.0, 10.0)
gen.add("leaf_size", double_t, 0, "VoxelGrid filter leaf size (in meters), only relevant if downsampling is enabled, otherwise ignored.", 0.005, 0.0, 0.5)
gen.add("plane_tolerance", double_t, 0, "Plane segmentation tolerance (in meters), only relevant if plane_segmentation is enabled, otherwise ignored.", 0.004, 0.00, 0.5)

#Estimator
gen.add("estimator_object_calibration", bool_t, 0, "Enable this flag only when performing object-star calibration. When this flag is enabled all estimated objects will be called <object>(for compatibility with calibration package).", False)
gen.add("estimator_iterations", int_t, 0, "Control Pose Estimation iterations, during candidate refinement with Progressive Bisection. (Increasing this value will increase estimation time)", 5, 1, 100)
gen.add("estimator_neighbors", int_t, 0, "Control how many neighbors are retrived from pose estimation database, each retrieved neighbor will then be refined with Progressive Bisection. (Increasing this value may improve recognition at the cost of execution time)", 10, 1, 100)
gen.add("estimator_clus_tol", double_t, 0, "Euclidean clustering tolerance (in meters), used to separate object clusters during table top segmentation.", 0.05, 0.001, 0.5)

#Broadcaster
gen.add("broadcaster_tf", bool_t, 0, "When this flag is enabled all tf transforms of objects will be broadcasted. (Relevant only if broadcaster module is enabled).", True)
gen.add("broadcaster_rviz_markers", bool_t, 0, "When true broadcast a marker array of objects for mesh visualization. (Relevant only if broadcaster is enabled)", True)

#Tracker
gen.add("tracker_bounding_factor", double_t, 0, "Multiplicative factor to object bounding box dimensions. Note that each dimension of the bounding box gets multiplied by this factor. (Relevant only if Tracker module is enabled)", 0.01, 1.1, 3.0)
gen.add("tracker_leaf_size", double_t, 0, "Leaf size for tracker internal voxel grid downsampling. (Relevant only if Tracker module is enabled)", 0.02, 0.001, 0.1)
type_enum = gen.enum([ gen.const("ICP",               int_t, 0,   "Use Iterative Closest Point for alignment"),
                       gen.const("Generalized_ICP",   int_t, 1,   "Use Generalized Iterative Closest Point for alignment"),
                       gen.const("Non_Linear_ICP",  int_t, 2,   "Use Iterative Closest Point Non Linear variant (Levenberg-Marquardt optimization) for alignment")],
                       "Chose Tracker type")
gen.add("tracker_type", int_t, 0, "Control which method to use during tracker alignment, if tracker is already started this value will take effect only when you restart it. (Relevant only if Tracker module is enabled)", 0,0,2, edit_method=type_enum)

exit(gen.generate(PACKAGE, "pacman_vision", "pacman_vision"))
