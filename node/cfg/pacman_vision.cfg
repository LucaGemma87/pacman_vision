#!/usr/bin/env python
PACKAGE = "pacman_vision"
from dynamic_reconfigure.parameter_generator_catkin import *

reconfigure = ParameterGenerator()
#           Name    Type  ReconfigureLevel    Description   Default   Min   Max
#Node
reconfigure.add("enable_estimator", bool_t, 0, "Enable Estimator module", False)
reconfigure.add("enable_tracker", bool_t, 0, "Enable Tracker module", False)
reconfigure.add("enable_broadcaster", bool_t, 0, "Enable Broadcaster module", False)
reconfigure.add("enable_listener", bool_t, 0, "Enable Vito listener module", False)
reconfigure.add("passthrough", bool_t, 0, "Enable Passthrough filter, applied to every pointcloud acquired from asus sensor", True)
reconfigure.add("downsampling", bool_t, 0, "Enable VoxelGrid filter, applied after the eventual passthrough filter and plane segmentation", False)
reconfigure.add("plane_segmentation", bool_t, 0, "Enable RANSAC fitting for plane and removal of found plane, applied after the eventual passthrough filter", False)
reconfigure.add("keep_organized", bool_t, 0, "Keep the point cloud organized during various filters, if possible (voxel grid breaks organized structure of point cloud).", False)
reconfigure.add("pass_xmin", double_t, 0, "Passthrough filter lower bound for X (in meters), only relevalt if filtering is enabled, otherwise ignored.", -0.5, -5.0, 5.0)
reconfigure.add("pass_xmax", double_t, 0, "Passthrough filter upper bound for X (in meters), only relevalt if filtering is enabled, otherwise ignored.", 0.5, -5.0, 5.0)
reconfigure.add("pass_ymin", double_t, 0, "Passthrough filter lower bound for Y (in meters), only relevalt if filtering is enabled, otherwise ignored.", -0.5, -5.0, 5.0)
reconfigure.add("pass_ymax", double_t, 0, "Passthrough filter upper bound for Y (in meters), only relevalt if filtering is enabled, otherwise ignored.", 0.5, -5.0, 5.0)
reconfigure.add("pass_zmin", double_t, 0, "Passthrough filter lower bound for Z (in meters), only relevalt if filtering is enabled, otherwise ignored.", 0.2, 0.1, 10.0)
reconfigure.add("pass_zmax", double_t, 0, "Passthrough filter upper bound for Z (in meters), only relevalt if filtering is enabled, otherwise ignored.", 1.0, 0.0, 10.0)
reconfigure.add("leaf_size", double_t, 0, "VoxelGrid filter leaf size (in meters), only relevant if downsampling is enabled, otherwise ignored.", 0.005, 0.001, 0.1)
reconfigure.add("plane_tolerance", double_t, 0, "Plane segmentation tolerance (in meters), only relevant if plane_segmentation is enabled, otherwise ignored.", 0.004, 0.00, 0.5)

#Estimator
reconfigure.add("estimator_object_calibration", bool_t, 0, "Enable this flag only when performing object-star calibration. When this flag is enabled all estimated objects will be called <object>(for compatibility with calibration package).", False)
reconfigure.add("estimator_iterations", int_t, 0, "Control Pose Estimation iterations, during candidate refinement with Progressive Bisection. (Increasing this value will increase estimation time)", 5, 1, 100)
reconfigure.add("estimator_neighbors", int_t, 0, "Control how many neighbors are retrived from pose estimation database, each retrieved neighbor will then be refined with Progressive Bisection. (Increasing this value may improve recognition at the cost of execution time)", 10, 1, 100)
reconfigure.add("estimator_clus_tol", double_t, 0, "Euclidean clustering tolerance (in meters), used to separate object clusters during table top segmentation.", 0.05, 0.001, 0.5)

#Broadcaster
reconfigure.add("broadcaster_tf", bool_t, 0, "When this flag is enabled all tf transforms of objects will be broadcasted. (Relevant only if broadcaster module is enabled).", True)
reconfigure.add("broadcaster_rviz_markers", bool_t, 0, "When true broadcast a marker array of objects for mesh visualization. (Relevant only if broadcaster is enabled)", True)

#Tracker
reconfigure.add("tracker_disturbance", bool_t, 0, "Trigger a manual disturbance to tracker (Relevant only if it is enabled).", False)
type_enum = reconfigure.enum([ reconfigure.const("DQ",   int_t, 0,   "Use Dual Quaternion method to estimate transformations"),
                       reconfigure.const("LM",   int_t, 1,   "Use Levenberg Marquardt method to estimate transformations"),
                       reconfigure.const("SVD",  int_t, 2,   "Use SVD-based method to estimate transformations"),
                       reconfigure.const("LLS",  int_t, 3,   "Use Linear Least Squares method to estimate transformations")],
                       "Chose transformation estimation type for Tracker")
reconfigure.add("tracker_estimation_type", int_t, 0, "Control which method to use during tracker transformation estimation. The chosen method is used to compute a transformation between source-target correspondences. (Relevant only if Tracker module is enabled)", 0,0,3, edit_method=type_enum)

exit(reconfigure.generate(PACKAGE, "pacman_vision", "pacman_vision"))
